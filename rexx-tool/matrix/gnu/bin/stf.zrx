/*
Why Rexx?
The distinguishing feature of Rexx is that it combines ease of use with power. Its goal is to make scripting
as easy, fast, reliable, and error-free as possible. Many programming languages are designed for compat-
ibility with older languages, the personal tastes of their inventors, the convenience of compiler-writers,
or machine optimization. Rexx ignores extraneous objectives. It was designed from day one to be power-
ful yet easy to use.
One person invented Rexx and guided its development: Michael Cowlishaw of IBM’s UK laboratories.
Cowlishaw gave the language the coherent vision and guiding hand that ambitious software projects
require to succeed. Anticipating how the Internet community would cooperate years later, he posted
Rexx on the ‘net of its day, IBM’s VNET, a network of tens of thousands of users. Cowlishaw solicited
and responded to thousands of emailed suggestions and recommendations on how people actually used
early Rexx. The feedback enabled Cowlishaw to adapt Rexx to typical human behavior, making Rexx a
truly easy-to-use language.
Ease of use is critical — even to experienced developers — because it leads to these benefits:
6
❑Low error rate — An easy-to-use language results in fewer bugs per program. Languages that rely
on arcane syntax, special characters and symbols, and default variables cause more errors.
❑Reliability — Programs are more reliable due to the lower error rate.
❑Longer-lived code — Maintenance costs dictate the usable life span of code. Rexx scripts are much
easier to maintain than scripts written in languages that rely on special characters and complex
syntax.
❑Reduced cost — Fast program development, coupled with a low error rate and high reliability,
lead to reduced costs. Ease of maintenance is critical because up to three-quarters of IT profes-
sionals engage in maintenance activities. Code written by others is easier to understand and
maintain if it is written in Rexx instead of syntax-driven languages like the shell languages or
Perl. This reduces labor costs.
❑Higher productivity — Developer productivity soars when the language is easy to work with.
Scripting in Rexx is more productive than coding in either lower-level compiled languages or
syntax-based shell languages.
❑Quicker testing — Interpretive scripting languages lend themselves to interactive testing.
Programmers get quick feedback and can easily trace program execution. Combined with the
low error rate of an easy-to-use language, this means that less test time is required.
❑Easy to learn — An easy-to-use language is easier to learn. If you have programmed in any other
programming or scripting language, you can pick up Rexx very quickly.
*/
queue die arg parse
interpret die
say '------------------------------------------'
say die "can't jure" failure 'jure...' to trace
say '------------------------------------------'
if die = 0 then
   say '---------------------------------------'
   say failure 'jure...' arg parse
   say scientific 'install' ...
   say scientific 'buffers' ...
   say scientific 'refunds' ...
   say '---------------------------------------'
return die
say error "cant't jure" failure 'jure...' to die
with die then
     say scientific to external arg parse 'rexx jure[1]'
     say scientific to external arg parse 'rexx jure[2]'
     say scientific to external arg parse 'rexx jure[3]'
procedure expose die
pull trace
if scientific = 1 then
   say '----------------------------------------------'
   say signal 'normative' failure 'jure(x,y)' to die
   say signal 1 to external arg parse
   say '----------------------------------------------' 
push trace
arg parse
exit
